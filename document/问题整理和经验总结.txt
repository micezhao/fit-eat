fit-eat 开发过程的问题记录和经验总结

第一周（2019/10/21 - 2019/10/27）
已完成任务：
1、通过frp方案实现内网穿透
    1.1 将【服务端frps】 部署到阿里云，作为代理服务器
    1.2 将【客户端frpc】 部署到imac，作为客户端
    *******【服务端frps】操作******
    1.3 修改(添加)服务端的frps.ini的配置 bind_port = 7000 #在服务端通过7000端口与客户端进行绑定
    1.4 启动frps服务
    *******【服务端frps】操作******
    1.5 修改(添加)客户端的frpc.ini的配置 , 此配置的目的，是将内网服务器与外网服务器关联起来
        [common]
        server_addr = 118.190.53.214
        server_port = 7000
    1.6 修改(添加)配置，使得内网服务器的ssh功能可以通过外网访问
        [ssh]
        type = tcp 
        local_ip = 127.0.0.1
        local_port = 22
        remote_port = 6000
    1.7 如上文述，几项重点节点的解释
        [xx]：节点说明，此配置内容不可重复
        type：通信协议类型 常用：tcp/http/https
        local_ip：内网服务器的ip地址，如果某个应用与frpc部署在同一台机器，则为127.0.0.1
        local_port：当前节点的应用对应的本机端口号 
        remote_port：当前应用通过外网暴露的访问端口号
        例子：
        [mysql]
        type = tcp
        local_ip = 127.0.0.1
        local_port = 3306
        remote_port = 3386
    1.8 修改完成后，启动frpc服务，启动完成后，可以监控日志检查代理连接情况，日志中出现如下信息，则表示代理成功
        [ssh] start proxy success
        [redis] start proxy success
        等等
    *******【阿里云服务】操作******
    1.9 阿里云作为外网服务的实际提供者，需要在阿里云控制台打开frpc中的remote_port配置项的端口，以便外网请求可以访问可以通过阿里云的安全控制策略

2、编辑配置清单/第一阶段的功能规划
    2.1 将开发过程中需要用到的相关配置信息，编辑成表格，对网络连接访问的相关信息，和开发环境的相关配置信息进行明确说明。此文件将随着功能开发的过程，持续维护；
    2.2 对第一阶段的功能进行规划，并作为里程碑，用来对照开发过程。

3、kobe系统的功能分析与对象设计
    3.1 理解oauth认证方式：这是一种当下场景的认证方案，意图通过将某个用户已经在其他应用中已经认证过的身份，作为本系统认证凭证，可以避免用户持有并记录过多的认证信息，降低用户方位新应用的门槛
    3.2 理解应用作为微信/支付宝小程序时，当用户访问本小程序时的授权操作的本意是，应用请求微信平台，需要获取当前用户在微信中的相关信息。而这个授权的动作是用户授权微信平台将信息提供给本应用的
    3.3 kobe系统的具备的功能分析：
        3.3.1 实现多渠道方位，多方式认证的支持
        3.3.2 实现同一用户通过不同渠道访问时的账户信息绑定
        3.3.3 高效的生成唯一的用户编号
        3.3.4 实现分布式的身份认证令牌的共享
    3.4 kobe系统的第一阶段功能所需要的对象分析
        3.4.1 本次对象分析，将基本对象与视图对象两种
        3.4.2 基本对象的相关数据，存入sql数据库，视图对象存入nosql数据库

4、基于springcloud技术栈搭建应用体系
    4.1 springboot 版本：2.2.0
    4.2 springcloud  版本：Hoxton.M3
    4.3 maven 构建模式

5、部署jordan/david 应用，使之可以被外网访问到
    5.1 jordan 作为注册中心
    5.2 david 作为配置中心

    ****【注意】****
    关于eureka-client注册的配置方式的区别：
    5.1 通过真实ip地址向eureka-server注册，配置如下：
    eureka:
        instance:
            lease-expiration-duration-in-seconds: 5 #设置心跳的周期间隔(默认90s)[如果5s没响应默认服务宕机]
            lease-renewal-interval-in-seconds: 2  #设置心跳时间间隔(默认30s)
            prefer-ip-address: true       #访问路径变为IP地址
            instance-id: ${spring.application.name}:${spring.cloud.client.ip-address}:${server.port} 
    采用此方式的注册，在eureka-server 的监控台中，将显示这个当前client的真实ip地址。【此方案使用在所有应用在同一套网络环境下】
    5.2、通过hostname的方式向eureka-server注册
     eureka:
        instance:
            hostname：imac-david
    采用此方式的注册，在eureka-server 的监控台中，将显示这个当前client的域名地址。【此方案使用在应用不在同一套网络环境下】
    5.3、通过实验证明：
        3.1 在springcloud体系中，当应用注册到eurka-server后，eureka将会维护一个serviceId与client所在网络地址的映射关系列表；
        3.2 请求达到eurka-server后，会通过映射关系列表，查找被访问的serviceId对应的网络地址，并将请求转发到目标地址；
        3.3 如果客户端之间可以通过注册到eureka的ip地址进行相互请求（即：所有应用在同一套网络环境下），那么请求之间可以正常调用
        3.4 如果应用不再同一个网络环境，那么应用之间的互相调用会失败。虽然可以通过serviceId进行转发，但是由于网络环境屏障，请求无法依然访问到serviceId对应的ip地址
        3.5 此时，就需要采用hostname的方式来注册客户端。同时在消费者所在系统改写host地址，将生产者的hostname与生产者的ip地址，在消费者本机进行绑定。
        3.6 这样一来，相当于在消费者本机进行了dns的解析。

第二周（2019/10/28 - 2019/11/01）
已完成的任务：
1、研究eureka的服务注册流程：
    ********【服务端启动和接受注册的流程】*********
    1.1 eureka-server的启动流程
        1.1.1 EurekaServerInitializerConfiguration 负责提供初始化eureka-server容器的初始化，
              这个类实现了 SmartLifecycle extends Lifecycle 的start()方法，用来在spring启动时加载eureka启动项
        1.1.2 在strat（）方法中完成如下事项：
                    ｜—— eurekaServerBootstrap.contextInitialized (EurekaServerInitializerConfiguration.this.servletContext）将eureka-server初始化到spring的上下文中
        1.1.3 publish(new EurekaRegistryAvailableEvent(getEurekaServerConfig())); 发布服务端可用时间
        1.1.4 EurekaServerInitializerConfiguration.this.running = true; 将EurekaServer的状态设置为运行状态；
        1.1.5 publish(new EurekaServerStartedEvent(getEurekaServerConfig())); 发布服务端启动事件
    1.2 EurekaServer启动后，将向外提供一个接受注册的方法:ApplicationResource.addInstance ,客户端可通过发送请求到 ip:port/eureka/apps/{id} 完成将client注册到EurekaServer中
    1.3 在ApplicationResource.addInstance方法中通过执行PeerAwareInstanceRegistry.registry(info, "true".equals(isReplication));，将完成服务注册的逻辑
        【info是InstanceInfo对象的实例，info由client端提供】
    1.4 registry方法最后落脚到AbstractInstanceRegistry类中的registry方法中，在AbstractInstanceRegistry.registry方法中，
        最后将这个info写入到 ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> 中，完成服务的注册步骤。
        这个map维护的是 serviceId 与这个serviceId对应的InstanceInfo的租约信息【Lease】的映射关系。
    1.5 Lease【租约】对象中存放了 InstanceInfo ,evictionTimestamp[失效时间],registrationTimestamp【注册时间】,serviceUpTimestamp【启动时间】等信息
    
    ********【客户端启动和接受注册的流程】*********
    1.6 eureka-client的启动流程
        1.6.1 在client端由EurekaAutoServiceRegistration 作为启动入口，与服务端一样，实现了Lifecycle的start（）方法，在启动时将eureka-client初始化到spring的上下文中
        1.6.2 在strat（）方法中，通过调用EurekaServiceRegistry.register方法来实现向服务端注册的执行逻辑；
    1.7 在调用EurekaServiceRegistry.register的过程中，
                    ｜——首先会通过ApplicationInfoManager【应用管理其】将客户端信息转化为InstanceInfo
                    ｜——此时，client还未完成启动过程，InstanceInfo的初始状态为starting
                    ｜——在启动完成后，会将InstanceInfo设置为up
    1.8 当Instanceinfo的状态为up后，会触发ApplicationInfoManager.StatusChangeListener监听器发起notify通知
    1.9 通知的内容将交给InstanceInfoReplicator.run（）方法中去执行
                    ｜——首先刷新这个instanceInfo的相关状态
                    ｜——调用discoveryClient.register()方法，准备开始进行注册
    1.10 在discoveryClient.register() 方法中 执行 httpResponse = eurekaTransport.registrationClient.register(instanceInfo); 向eureka-server进行注册
    1.11 最后使用EurekaHttpClient接口的AbstractJerseyEurekaHttpClient实现类中的register方法，向ip:port/eureka/apps/{id} 发送请求，发送的内容就是InstanceInfo

    至此：eureka server/client 的启动与注册流程就执行完毕
    同时，为了维护server/client之间的关系，client端将由一个定时任务 scheduleTask定时向sever发送心跳，来维持连接
    


    