fit-eat 开发过程的问题记录和经验总结

第一周（2019/10/21 - 2019/10/27）
已完成任务：
1、通过frp方案实现内网穿透
    1.1 将【服务端frps】 部署到阿里云，作为代理服务器
    1.2 将【客户端frpc】 部署到imac，作为客户端
    *******【服务端frps】操作******
    1.3 修改(添加)服务端的frps.ini的配置 bind_port = 7000 #在服务端通过7000端口与客户端进行绑定
    1.4 启动frps服务
    *******【服务端frps】操作******
    1.5 修改(添加)客户端的frpc.ini的配置 , 此配置的目的，是将内网服务器与外网服务器关联起来
        [common]
        server_addr = 118.190.53.214
        server_port = 7000
    1.6 修改(添加)配置，使得内网服务器的ssh功能可以通过外网访问
        [ssh]
        type = tcp 
        local_ip = 127.0.0.1
        local_port = 22
        remote_port = 6000
    1.7 如上文述，几项重点节点的解释
        [xx]：节点说明，此配置内容不可重复
        type：通信协议类型 常用：tcp/http/https
        local_ip：内网服务器的ip地址，如果某个应用与frpc部署在同一台机器，则为127.0.0.1
        local_port：当前节点的应用对应的本机端口号 
        remote_port：当前应用通过外网暴露的访问端口号
        例子：
        [mysql]
        type = tcp
        local_ip = 127.0.0.1
        local_port = 3306
        remote_port = 3386
    1.8 修改完成后，启动frpc服务，启动完成后，可以监控日志检查代理连接情况，日志中出现如下信息，则表示代理成功
        [ssh] start proxy success
        [redis] start proxy success
        等等
    *******【阿里云服务】操作******
    1.9 阿里云作为外网服务的实际提供者，需要在阿里云控制台打开frpc中的remote_port配置项的端口，以便外网请求可以访问可以通过阿里云的安全控制策略

2、编辑配置清单/第一阶段的功能规划
    2.1 将开发过程中需要用到的相关配置信息，编辑成表格，对网络连接访问的相关信息，和开发环境的相关配置信息进行明确说明。此文件将随着功能开发的过程，持续维护；
    2.2 对第一阶段的功能进行规划，并作为里程碑，用来对照开发过程。

3、kobe系统的功能分析与对象设计
    3.1 理解oauth认证方式：这是一种当下场景的认证方案，意图通过将某个用户已经在其他应用中已经认证过的身份，作为本系统认证凭证，可以避免用户持有并记录过多的认证信息，降低用户方位新应用的门槛
    3.2 理解应用作为微信/支付宝小程序时，当用户访问本小程序时的授权操作的本意是，应用请求微信平台，需要获取当前用户在微信中的相关信息。而这个授权的动作是用户授权微信平台将信息提供给本应用的
    3.3 kobe系统的具备的功能分析：
        3.3.1 实现多渠道方位，多方式认证的支持
        3.3.2 实现同一用户通过不同渠道访问时的账户信息绑定
        3.3.3 高效的生成唯一的用户编号
        3.3.4 实现分布式的身份认证令牌的共享
    3.4 kobe系统的第一阶段功能所需要的对象分析
        3.4.1 本次对象分析，将基本对象与视图对象两种
        3.4.2 基本对象的相关数据，存入sql数据库，视图对象存入nosql数据库

4、基于springcloud技术栈搭建应用体系
    4.1 springboot 版本：2.2.0
    4.2 springcloud  版本：Hoxton.M3
    4.3 maven 构建模式

5、部署jordan/david 应用，使之可以被外网访问到
    5.1 jordan 作为注册中心
    5.2 david 作为配置中心

    ****【注意】****
    关于eureka-client注册的配置方式的区别：
    5.1 通过真实ip地址向eureka-server注册，配置如下：
    eureka:
        instance:
            lease-expiration-duration-in-seconds: 5 #设置心跳的周期间隔(默认90s)[如果5s没响应默认服务宕机]
            lease-renewal-interval-in-seconds: 2  #设置心跳时间间隔(默认30s)
            prefer-ip-address: true       #访问路径变为IP地址
            instance-id: ${spring.application.name}:${spring.cloud.client.ip-address}:${server.port} 
    采用此方式的注册，在eureka-server 的监控台中，将显示这个当前client的真实ip地址。【此方案使用在所有应用在同一套网络环境下】
    5.2、通过hostname的方式向eureka-server注册
     eureka:
        instance:
            hostname：imac-david
    采用此方式的注册，在eureka-server 的监控台中，将显示这个当前client的域名地址。【此方案使用在应用不在同一套网络环境下】
    5.3、通过实验证明：
        3.1 在springcloud体系中，当应用注册到eurka-server后，eureka将会维护一个serviceId与client所在网络地址的映射关系列表；
        3.2 请求达到eurka-server后，会通过映射关系列表，查找被访问的serviceId对应的网络地址，并将请求转发到目标地址；
        3.3 如果客户端之间可以通过注册到eureka的ip地址进行相互请求（即：所有应用在同一套网络环境下），那么请求之间可以正常调用
        3.4 如果应用不再同一个网络环境，那么应用之间的互相调用会失败。虽然可以通过serviceId进行转发，但是由于网络环境屏障，请求无法依然访问到serviceId对应的ip地址
        3.5 此时，就需要采用hostname的方式来注册客户端。同时在消费者所在系统改写host地址，将生产者的hostname与生产者的ip地址，在消费者本机进行绑定。
        3.6 这样一来，相当于在消费者本机进行了dns的解析。

第二周（2019/10/28 - 2019/11/01）
已完成的任务：
1、研究eureka的服务注册流程：
    ********【服务端启动和接受注册的流程】*********
    1.1 eureka-server的启动流程
        1.1.1 EurekaServerInitializerConfiguration 负责提供初始化eureka-server容器的初始化，
              这个类实现了 SmartLifecycle extends Lifecycle 的start()方法，用来在spring启动时加载eureka启动项
        1.1.2 在strat（）方法中完成如下事项：
                    ｜—— eurekaServerBootstrap.contextInitialized (EurekaServerInitializerConfiguration.this.servletContext）将eureka-server初始化到spring的上下文中
        1.1.3 publish(new EurekaRegistryAvailableEvent(getEurekaServerConfig())); 发布服务端可用时间
        1.1.4 EurekaServerInitializerConfiguration.this.running = true; 将EurekaServer的状态设置为运行状态；
        1.1.5 publish(new EurekaServerStartedEvent(getEurekaServerConfig())); 发布服务端启动事件
    1.2 EurekaServer启动后，将向外提供一个接受注册的方法:ApplicationResource.addInstance ,客户端可通过发送请求到 ip:port/eureka/apps/{id} 完成将client注册到EurekaServer中
    1.3 在ApplicationResource.addInstance方法中通过执行PeerAwareInstanceRegistry.registry(info, "true".equals(isReplication));，将完成服务注册的逻辑
        【info是InstanceInfo对象的实例，info由client端提供】
    1.4 registry方法最后落脚到AbstractInstanceRegistry类中的registry方法中，在AbstractInstanceRegistry.registry方法中，
        最后将这个info写入到 ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> 中，完成服务的注册步骤。
        【2019-11-04 提问：最外层的key存的是什么】
        这个map维护的是 serviceId 与这个serviceId对应的InstanceInfo的租约信息【Lease】的映射关系。
    1.5 Lease【租约】对象中存放了 InstanceInfo ,evictionTimestamp[失效时间],registrationTimestamp【注册时间】,serviceUpTimestamp【启动时间】等信息
    
    ********【客户端启动和接受注册的流程】*********
    1.6 eureka-client的启动流程
        1.6.1 在client端由EurekaAutoServiceRegistration 作为启动入口，与服务端一样，实现了Lifecycle的start（）方法，在启动时将eureka-client初始化到spring的上下文中
        1.6.2 在strat（）方法中，通过调用EurekaServiceRegistry.register方法来实现向服务端注册的执行逻辑；
    1.7 在调用EurekaServiceRegistry.register的过程中，
                    ｜——首先会通过ApplicationInfoManager【应用管理器】将客户端信息转化为InstanceInfo
                    ｜——此时，client还未完成启动过程，InstanceInfo的初始状态为starting
                    ｜——在启动完成后，会将InstanceInfo设置为up
    1.8 当Instanceinfo的状态为up后，会触发ApplicationInfoManager.StatusChangeListener监听器发起notify通知
    1.9 通知的内容将交给InstanceInfoReplicator.run（）方法中去执行
                    ｜——首先刷新这个instanceInfo的相关状态
                    ｜——调用discoveryClient.register()方法，准备开始进行注册
    1.10 在discoveryClient.register() 方法中 执行 httpResponse = eurekaTransport.registrationClient.register(instanceInfo); 向eureka-server进行注册
    1.11 最后使用EurekaHttpClient接口的AbstractJerseyEurekaHttpClient实现类中的register方法，向ip:port/eureka/apps/{id} 发送请求，发送的内容就是InstanceInfo

    至此：eureka server/client 的启动与注册流程就执行完毕
    同时，为了维护server/client之间的关系，client端将由一个定时任务 scheduleTask定时向sever发送心跳，来维持连接，而在server由Lookup类来轮训当前处于注册列表中的服务
    
2、通过自定义注解+aop的方式实现将mysql数据同步到mongodb的操作
    2.1 关于mongodb的数据库系统的权限控制和连接管理
    2.2 关于对java提供的注解的深入学习
        java中的注解分为元注解与注解（包括：java提供的注解和自定义注解），其中元注解是有java语言提供的，作用是描述或限定自定义注解的注解
        常用的元注解有：
        @Target：用于限定注解的作用位置，例如：@Target({ElementType.METHOD,ElementType.PARAMETER,ElementType.FIELD}
        @Retention:声明注解的保留期，常用：@Retention(RetentionPolicy.RUNTIME)，表示在运行期间jvm可以通过反射获得该注解的相关信息
        @Document:说明被修饰的注解是否需要包含Javadoc中
        @Inherited:描述这个注解可以被继承，假设注解 @AnnoTest被元注解@Inherited修饰，类A 被@AnnoTest修饰，类B继承了A，那么B也被@AnnoTest修饰
        java的提供的注解有：
        @Override，表示当前的方法定义将覆盖超类中的方法。
        @Deprecated，使用了注解为它的元素编译器将发出警告，因为注解@Deprecated是不赞成使用的代码，被弃用的代码。
        @SuppressWarnings,关闭不当编辑器警告信息。
        自定义注解：
        自定义注解是一个特殊的接口，声明的方法是@Interface ，在自定义注解接口中可以定义接口中的方法及其默认值 
        @Target(ElementType.METHOD)
        @Retention(RetentionPolicy.RUNTIME)
        public @interface UseCases{
            public String id();
            public String description() default "no description";
        }
        在运行时可以通过java的反射来获得这个注解的相关信息，
		Annotation[] annotations01 = Class.getAnnotations();
    2.3 将自定义注解作用结合AOP实现功能的扩展（这也是一种装饰器模式）
        2.3.1 自定义一个注解 例如：@ToMongoDB
        2.3.2 准备一个Aspect类
        2.3.3 指定 @Before/@After/@Around 通知注解的value属性为自定义注解 @After(value = "@annotation(ToMongoDB)") 
        2.3.4 在切面的方法中，编写程序逻辑，即可
    2.4 关于springboot的自动化配置：
        自动化配置可以说是springboot框架中最重要的一个功能之一，在了解springboot的自动化配置功能(spring-boot-autoconfigure.jar)之前，首先要了解springboot可以自动化的配置哪些内容
        2.4.1 在spring-boot-autoconfigure.jar的/MATA-INF 维护两个文件 spring.factories 和 spring-autoconfigure-metadata.properties 两个文件
              spring.factories:声明了可以被自动化配置的组件/模块/功能列表
              spring-autoconfigure-metadata.properties:维护了各组件/模块/功能列表的代码入口
        那么为什么需要这个功能呢？
        这就要从spring的历史说起，spring框架具有面向接口编程的特点，这个特点使得spring框架本身具有极强的兼容性和扩展能力。
        当开发者需要在项目中使用到某个中间件时（例如：jdbc，mq，cache）时，只需要编写一个专门的xml配置文件将这个组件与spring框架对接起来，也就是：将Spring框架提供的对应的接口与组件的实现进行匹配
        以向spring框架中集成一个消息中间为例：https://blog.csdn.net/isea533/article/details/84545484
        试想：如果一个工程需要配置诸多中间件时，且在一个多工程聚合的项目中，这种xml配置文件就需要耗费大量的维护成本。
        因此springboot提高了自动化配置的功能，是基于”约定优于配置“的原则，将这些可能会用到的，并且Spring已经提供了实现了的组件进行同一的管理。
        让开发人员只需通过配置文件来声明一些【如连接信息】个性化程度很高的配置项参数，就可以实现中间的集成。这样以来，极大的简化了工程项目的集成难度，让开发者可以更多的将经历投入在业务开发中。
        那Springboot是如何完成自动化配置的呢？
        2.4.2.1 自动配置的入口：main中的SpringApplication.run(xxApplication.Class,args)方法 => args是来自springboot项目通过命令启动时的启动参数，例如 java -jar my-spring-boot.jar --spring.profiles.active=prod 其中 --spring.profiles.active=prod就时args的一部分
        2.4.2.2 自动化配置是通过注解@SpringBootApplication 来进行，@SpringBootApplication -> @Target(ElementType.TYPE) 这个注解作用与类上
        2.4.2.3 可以被自动配置的组件：@SpringBootApplication - >import @EnableAutoConfiguration -> @Import(AutoConfigurationImportSelector.class)
                AutoConfigurationImportSelector.class -> 
                    selectImports -> (
                        getAutoConfigurationEntry - (
                            getAutoConfigurationEntry -> (
                                getCandidateConfigurations -- （ // 获得候选人
                                    SpringFactoriesLoader.loadFactoryNames(
                                      -> loadSpringFactories( // FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";
                                          classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : 
					                      ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
                                        ) 读取完成后，将需要被自动加载的内容存储在一个 LinkedMultiValueMap<>()中;
                                    ）
                                )
                            )
                        )
                    ) == >> 执行完成后，封装成 AutoConfigurationEntry.class --> AutoConfigurationEntry(Collection<String> configurations, Collection<String> exclusions) 
        2.4.2.4 哪些组件将会被加载 @SpringBootApplication - > @ComponentScan 扫描整个项目中的bean，
                 当工程中引用了spring.factories中的某个组件后，将会被扫描到从而成为一个在项目启动过程总需要被加载的组件
        2.4.2.5 项目启动，开始加载 SpringApplication.class --> 
                run(
                     getRunListeners(
                         getSpringFactoriesInstances(
                             createSpringFactoriesInstances( //并将他们创建成一个 java的实例 
                                 SpringFactoriesLoader.loadFactoryNames() // 从"META-INF/spring.factories" 中获取要加载的配置
                             )
                         )
                     )
                     prepareContext(
                         listeners.contextPrepared(context); //将这些监听器的实例放入转为上下文
                     )
                     ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
		             beanFactory.registerSingleton("springApplicationArguments", applicationArguments); // 将上下文中的内容变成一个singleton bean
                     listeners.contextLoaded(context); // 启动被监听的监视器
                )
        2.4.2.6 项目启动的过程中，诸多被加载的组件也需要同步开始运行，而这些组件大多需要进行一些额外的配置，例如数据库的连接信息，消息中间的服务端地址
                这些额外的配置通过spring-autoconfigure-metadata.properties文件中指定的组件代码入口上的@EnableConfigurationProperties(xxxProperties.class)
                xxxProperties.class来读取额外的配置信息


       

3、设计模式（一）：
    3.1 装饰器模式：结构型模式
        装饰器模式践行了设计模式大原则中的开闭原则（即：对扩展开发，对修改关闭），其作用在于在不改变原有功能的前提下，通过装饰器对功能提供扩展
        实现装饰器的条件：
        准备过程：
        1、baseClass = > method_1,method_2,...,method_n
        2、decorateClass =>protected arg baseClass , constructor(baseClass),@Override method_1( extendtion method)
        调用方式：
        DecorateClass decorateClass = new DecorateClass(baseClass); // 通过装饰器类对基类进行包装
        decorateClass.method_1() => 此时执行的是被扩展的method_1 的结果 
        装饰器本身最好是一个abstract类，方便被同类型但需要个性化扩展方法的类继承并重写装饰的方法
    3.2 策略模式：


第三周(2019/11/04 - 2019/11/08) 
已完成的任务：
1、学习spring-session组件，以及通过spring session 来实现分布式回话管理
    1.1 session是什么？
        在解释session是什么之前，先了解一下一个网络请求的执行过程。大部分的网络请求都使用http/https协议进行，这种通信协议的具有无状态的
        【无状态性】指：上一个请求和下一个请求之间是没有任何关联，上个请求中的结果不会影响下个请求。
        设想一个情景：即如果 url—1 是负责对请求者身份进行认证，url-2是向用户提供购物功能。基于http协议的无状态性，用户通过url-1完成了身份认证，
        跳转到url-2，但是url-2无法从url-1中获取用户的任何信息，必须要再次进行一次查询操作才能获得用户的相关信息。这样势必会十分影响系统性能。
        为了解决这个问题，首先诞生了【cookie技术】，这种在服务器相应了客户端请求后，将和客户端操作相关的一小部分信息存储与客户端（例如：浏览器中）
        这样一来，就可以将通过上个请求拿到的相关信息留存下来，供下一个请求使用。但是，cookie存在容量和安全问题，因为信息存放于客户端，用户便可以随意修改cookie中存放的信息。
        因此，更进一步【session技术】就应运而生了。session不仅保存请求过程产生的信息，还因其存放与服务端用户不能随意修改，保证了信息的安全性。
    1.2 session是一种控制管理前后台请求访问过程中产生的一些通用信息的技术。例如，a页面会产生用户信息，b页面需要获得用户名字，c页面需要获取用户年龄
        如果有session的介入，就可以将访问a页面时的用户信息存入【session指定的容器】中，b,c页面可以从session容器中获得需要的信息
    1.3 session容器：是指用来存储会话中产生的相关信息的地方。
        最初这些会话信息是存放在网络服务器中（例如：tomcat），会话信息只能在当前tomcat中流转。
        但是，随着互联网技术的发展和微服务架构被广泛使用后，每个微服务都独享资源，那么会话就需要在这个微服务集中共享。因此，可以将某些具有存储功能的中间当作session容器
        例如：redis，mongodb，sql数据库
    1.4 session是怎么生成的？
        session是有服务端控制的会话技术，因此session也是来自于后端
        session产生的流程：客户端发起请求 访问 httpServletReqeust接口并调用其get.session(ture)方法，
        如果是客户端的第一次请求,那么就会为本次会话创建一个session信息，可以用来存放客户端与服务端交互过程中需要用到的相关信息，并且生成一个sessionId返回给客户端，sessionid是客户端维护与服务端会话的重要唯一标示
        sessionId -> session
        如果客户端已经访问过服务端，那么就通过sessionId获取已存在的session信息
        session完全由服务端控制，一个session信息的创建，修改，删除都是在服务端进行。因此假定一个浏览器关闭了，是不会删除session信息。除非打开另一个浏览器时，这样就服务器就会将其认定为另一个客户端，sessionId将重新生成
    1.4 spring session:是一套有spring提供的实现session管理的接口
        使用 spring-session-redis来管理session
        1.4.1 引入依赖
        1.4.2 进行配置：redis的连接配置，springsession的属性配置
                     【未解决指定session的redis db】
        1.4.3 配置session的序列化策略：com.f.a.kobe.config.SessionConfig
        
        

