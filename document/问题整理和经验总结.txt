fit-eat 开发过程的问题记录和经验总结

第一周（2019/10/21 - 2019/10/27）
已完成任务：
1、通过frp方案实现内网穿透
    1.1 将【服务端frps】 部署到阿里云，作为代理服务器
    1.2 将【客户端frpc】 部署到imac，作为客户端
    *******【服务端frps】操作******
    1.3 修改(添加)服务端的frps.ini的配置 bind_port = 7000 #在服务端通过7000端口与客户端进行绑定
    1.4 启动frps服务
    *******【服务端frps】操作******
    1.5 修改(添加)客户端的frpc.ini的配置 , 此配置的目的，是将内网服务器与外网服务器关联起来
        [common]
        server_addr = 118.190.53.214
        server_port = 7000
    1.6 修改(添加)配置，使得内网服务器的ssh功能可以通过外网访问
        [ssh]
        type = tcp 
        local_ip = 127.0.0.1
        local_port = 22
        remote_port = 6000
    1.7 如上文述，几项重点节点的解释
        [xx]：节点说明，此配置内容不可重复
        type：通信协议类型 常用：tcp/http/https
        local_ip：内网服务器的ip地址，如果某个应用与frpc部署在同一台机器，则为127.0.0.1
        local_port：当前节点的应用对应的本机端口号 
        remote_port：当前应用通过外网暴露的访问端口号
        例子：
        [mysql]
        type = tcp
        local_ip = 127.0.0.1
        local_port = 3306
        remote_port = 3386
    1.8 修改完成后，启动frpc服务，启动完成后，可以监控日志检查代理连接情况，日志中出现如下信息，则表示代理成功
        [ssh] start proxy success
        [redis] start proxy success
        等等
    *******【阿里云服务】操作******
    1.9 阿里云作为外网服务的实际提供者，需要在阿里云控制台打开frpc中的remote_port配置项的端口，以便外网请求可以访问可以通过阿里云的安全控制策略

2、编辑配置清单/第一阶段的功能规划
    2.1 将开发过程中需要用到的相关配置信息，编辑成表格，对网络连接访问的相关信息，和开发环境的相关配置信息进行明确说明。此文件将随着功能开发的过程，持续维护；
    2.2 对第一阶段的功能进行规划，并作为里程碑，用来对照开发过程。

3、kobe系统的功能分析与对象设计
    3.1 理解oauth认证方式：这是一种当下场景的认证方案，意图通过将某个用户已经在其他应用中已经认证过的身份，作为本系统认证凭证，可以避免用户持有并记录过多的认证信息，降低用户方位新应用的门槛
    3.2 理解应用作为微信/支付宝小程序时，当用户访问本小程序时的授权操作的本意是，应用请求微信平台，需要获取当前用户在微信中的相关信息。而这个授权的动作是用户授权微信平台将信息提供给本应用的
    3.3 kobe系统的具备的功能分析：
        3.3.1 实现多渠道方位，多方式认证的支持
        3.3.2 实现同一用户通过不同渠道访问时的账户信息绑定
        3.3.3 高效的生成唯一的用户编号
        3.3.4 实现分布式的身份认证令牌的共享
    3.4 kobe系统的第一阶段功能所需要的对象分析
        3.4.1 本次对象分析，将基本对象与视图对象两种
        3.4.2 基本对象的相关数据，存入sql数据库，视图对象存入nosql数据库

4、基于springcloud技术栈搭建应用体系
    4.1 springboot 版本：2.2.0
    4.2 springcloud  版本：Hoxton.M3
    4.3 maven 构建模式

5、部署jordan/david 应用，使之可以被外网访问到
    5.1 jordan 作为注册中心
    5.2 david 作为配置中心

    ****【注意】****
    关于eureka-client注册的配置方式的区别：
    5.1 通过真实ip地址向eureka-server注册，配置如下：
    eureka:
        instance:
            lease-expiration-duration-in-seconds: 5 #设置心跳的周期间隔(默认90s)[如果5s没响应默认服务宕机]
            lease-renewal-interval-in-seconds: 2  #设置心跳时间间隔(默认30s)
            prefer-ip-address: true       #访问路径变为IP地址
            instance-id: ${spring.application.name}:${spring.cloud.client.ip-address}:${server.port} 
    采用此方式的注册，在eureka-server 的监控台中，将显示这个当前client的真实ip地址。【此方案使用在所有应用在同一套网络环境下】
    5.2、通过hostname的方式向eureka-server注册
     eureka:
        instance:
            hostname：imac-david
    采用此方式的注册，在eureka-server 的监控台中，将显示这个当前client的域名地址。【此方案使用在应用不在同一套网络环境下】
    5.3、通过实验证明：
        3.1 在springcloud体系中，当应用注册到eurka-server后，eureka将会维护一个serviceId与client所在网络地址的映射关系列表；
        3.2 请求达到eurka-server后，会通过映射关系列表，查找被访问的serviceId对应的网络地址，并将请求转发到目标地址；
        3.3 如果客户端之间可以通过注册到eureka的ip地址进行相互请求（即：所有应用在同一套网络环境下），那么请求之间可以正常调用
        3.4 如果应用不再同一个网络环境，那么应用之间的互相调用会失败。虽然可以通过serviceId进行转发，但是由于网络环境屏障，请求无法依然访问到serviceId对应的ip地址
        3.5 此时，就需要采用hostname的方式来注册客户端。同时在消费者所在系统改写host地址，将生产者的hostname与生产者的ip地址，在消费者本机进行绑定。
        3.6 这样一来，相当于在消费者本机进行了dns的解析。

第二周（2019/10/28 - 2019/11/01）
已完成的任务：
1、研究eureka的服务注册流程：
    ********【服务端启动和接受注册的流程】*********
    1.1 eureka-server的启动流程
        1.1.1 EurekaServerInitializerConfiguration 负责提供初始化eureka-server容器的初始化，
              这个类实现了 SmartLifecycle extends Lifecycle 的start()方法，用来在spring启动时加载eureka启动项
        1.1.2 在strat（）方法中完成如下事项：
                    ｜—— eurekaServerBootstrap.contextInitialized (EurekaServerInitializerConfiguration.this.servletContext）将eureka-server初始化到spring的上下文中
        1.1.3 publish(new EurekaRegistryAvailableEvent(getEurekaServerConfig())); 发布服务端可用时间
        1.1.4 EurekaServerInitializerConfiguration.this.running = true; 将EurekaServer的状态设置为运行状态；
        1.1.5 publish(new EurekaServerStartedEvent(getEurekaServerConfig())); 发布服务端启动事件
    1.2 EurekaServer启动后，将向外提供一个接受注册的方法:ApplicationResource.addInstance ,客户端可通过发送请求到 ip:port/eureka/apps/{id} 完成将client注册到EurekaServer中
    1.3 在ApplicationResource.addInstance方法中通过执行PeerAwareInstanceRegistry.registry(info, "true".equals(isReplication));，将完成服务注册的逻辑
        【info是InstanceInfo对象的实例，info由client端提供】
    1.4 registry方法最后落脚到AbstractInstanceRegistry类中的registry方法中，在AbstractInstanceRegistry.registry方法中，
        最后将这个info写入到 ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> 中，完成服务的注册步骤。
        【2019-11-04 提问：最外层的key存的是什么】
        这个map维护的是 serviceId 与这个serviceId对应的InstanceInfo的租约信息【Lease】的映射关系。
    1.5 Lease【租约】对象中存放了 InstanceInfo ,evictionTimestamp[失效时间],registrationTimestamp【注册时间】,serviceUpTimestamp【启动时间】等信息
    
    ********【客户端启动和接受注册的流程】*********
    1.6 eureka-client的启动流程
        1.6.1 在client端由EurekaAutoServiceRegistration 作为启动入口，与服务端一样，实现了Lifecycle的start（）方法，在启动时将eureka-client初始化到spring的上下文中
        1.6.2 在strat（）方法中，通过调用EurekaServiceRegistry.register方法来实现向服务端注册的执行逻辑；
    1.7 在调用EurekaServiceRegistry.register的过程中，
                    ｜——首先会通过ApplicationInfoManager【应用管理器】将客户端信息转化为InstanceInfo
                    ｜——此时，client还未完成启动过程，InstanceInfo的初始状态为starting
                    ｜——在启动完成后，会将InstanceInfo设置为up
    1.8 当Instanceinfo的状态为up后，会触发ApplicationInfoManager.StatusChangeListener监听器发起notify通知
    1.9 通知的内容将交给InstanceInfoReplicator.run（）方法中去执行
                    ｜——首先刷新这个instanceInfo的相关状态
                    ｜——调用discoveryClient.register()方法，准备开始进行注册
    1.10 在discoveryClient.register() 方法中 执行 httpResponse = eurekaTransport.registrationClient.register(instanceInfo); 向eureka-server进行注册
    1.11 最后使用EurekaHttpClient接口的AbstractJerseyEurekaHttpClient实现类中的register方法，向ip:port/eureka/apps/{id} 发送请求，发送的内容就是InstanceInfo

    至此：eureka server/client 的启动与注册流程就执行完毕
    同时，为了维护server/client之间的关系，client端将由一个定时任务 scheduleTask定时向sever发送心跳，来维持连接，而在server由Lookup类来轮训当前处于注册列表中的服务
    
2、通过自定义注解+aop的方式实现将mysql数据同步到mongodb的操作
    2.1 关于mongodb的数据库系统的权限控制和连接管理
    2.2 关于对java提供的注解的深入学习
        java中的注解分为元注解与注解（包括：java提供的注解和自定义注解），其中元注解是有java语言提供的，作用是描述或限定自定义注解的注解
        常用的元注解有：
        @Target：用于限定注解的作用位置，例如：@Target({ElementType.METHOD,ElementType.PARAMETER,ElementType.FIELD}
        @Retention:声明注解的保留期，常用：@Retention(RetentionPolicy.RUNTIME)，表示在运行期间jvm可以通过反射获得该注解的相关信息
        @Document:说明被修饰的注解是否需要包含Javadoc中
        @Inherited:描述这个注解可以被继承，假设注解 @AnnoTest被元注解@Inherited修饰，类A 被@AnnoTest修饰，类B继承了A，那么B也被@AnnoTest修饰
        java的提供的注解有：
        @Override，表示当前的方法定义将覆盖超类中的方法。
        @Deprecated，使用了注解为它的元素编译器将发出警告，因为注解@Deprecated是不赞成使用的代码，被弃用的代码。
        @SuppressWarnings,关闭不当编辑器警告信息。
        自定义注解：
        自定义注解是一个特殊的接口，声明的方法是@Interface ，在自定义注解接口中可以定义接口中的方法及其默认值 
        @Target(ElementType.METHOD)
        @Retention(RetentionPolicy.RUNTIME)
        public @interface UseCases{
            public String id();
            public String description() default "no description";
        }
        在运行时可以通过java的反射来获得这个注解的相关信息，
		Annotation[] annotations01 = Class.getAnnotations();
    2.3 将自定义注解作用结合AOP实现功能的扩展（这也是一种装饰器模式）
        2.3.1 自定义一个注解 例如：@ToMongoDB
        2.3.2 准备一个Aspect类
        2.3.3 指定 @Before/@After/@Around 通知注解的value属性为自定义注解 @After(value = "@annotation(ToMongoDB)") 
        2.3.4 在切面的方法中，编写程序逻辑，即可
    2.4 关于springboot的自动化配置：
        自动化配置可以说是springboot框架中最重要的一个功能之一，在了解springboot的自动化配置功能(spring-boot-autoconfigure.jar)之前，首先要了解springboot可以自动化的配置哪些内容
        2.4.1 在spring-boot-autoconfigure.jar的/MATA-INF 维护两个文件 spring.factories 和 spring-autoconfigure-metadata.properties 两个文件
              spring.factories:声明了可以被自动化配置的组件/模块/功能列表
              spring-autoconfigure-metadata.properties:维护了各组件/模块/功能列表的代码入口
        那么为什么需要这个功能呢？
        这就要从spring的历史说起，spring框架具有面向接口编程的特点，这个特点使得spring框架本身具有极强的兼容性和扩展能力。
        当开发者需要在项目中使用到某个中间件时（例如：jdbc，mq，cache）时，只需要编写一个专门的xml配置文件将这个组件与spring框架对接起来，也就是：将Spring框架提供的对应的接口与组件的实现进行匹配
        以向spring框架中集成一个消息中间为例：https://blog.csdn.net/isea533/article/details/84545484
        试想：如果一个工程需要配置诸多中间件时，且在一个多工程聚合的项目中，这种xml配置文件就需要耗费大量的维护成本。
        因此springboot提高了自动化配置的功能，是基于”约定优于配置“的原则，将这些可能会用到的，并且Spring已经提供了实现了的组件进行同一的管理。
        让开发人员只需通过配置文件来声明一些【如连接信息】个性化程度很高的配置项参数，就可以实现中间的集成。这样以来，极大的简化了工程项目的集成难度，让开发者可以更多的将经历投入在业务开发中。
        那Springboot是如何完成自动化配置的呢？
        2.4.2.1 自动配置的入口：main中的SpringApplication.run(xxApplication.Class,args)方法 => args是来自springboot项目通过命令启动时的启动参数，例如 java -jar my-spring-boot.jar --spring.profiles.active=prod 其中 --spring.profiles.active=prod就时args的一部分
        2.4.2.2 自动化配置是通过注解@SpringBootApplication 来进行，@SpringBootApplication -> @Target(ElementType.TYPE) 这个注解作用与类上
        2.4.2.3 可以被自动配置的组件：@SpringBootApplication - >import @EnableAutoConfiguration -> @Import(AutoConfigurationImportSelector.class)
                AutoConfigurationImportSelector.class -> 
                    selectImports -> (
                        getAutoConfigurationEntry - (
                            getAutoConfigurationEntry -> (
                                getCandidateConfigurations -- （ // 获得候选人
                                    SpringFactoriesLoader.loadFactoryNames(
                                      -> loadSpringFactories( // FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";
                                          classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : 
					                      ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
                                        ) 读取完成后，将需要被自动加载的内容存储在一个 LinkedMultiValueMap<>()中;
                                    ）
                                )
                            )
                        )
                    ) == >> 执行完成后，封装成 AutoConfigurationEntry.class --> AutoConfigurationEntry(Collection<String> configurations, Collection<String> exclusions) 
        2.4.2.4 哪些组件将会被加载 @SpringBootApplication - > @ComponentScan 扫描整个项目中的bean，
                 当工程中引用了spring.factories中的某个组件后，将会被扫描到从而成为一个在项目启动过程总需要被加载的组件
        2.4.2.5 项目启动，开始加载 SpringApplication.class --> 
                run(
                     getRunListeners(
                         getSpringFactoriesInstances(
                             createSpringFactoriesInstances( //并将他们创建成一个 java的实例 
                                 SpringFactoriesLoader.loadFactoryNames() // 从"META-INF/spring.factories" 中获取要加载的配置
                             )
                         )
                     )
                     prepareContext(
                         listeners.contextPrepared(context); //将这些监听器的实例放入转为上下文
                     )
                     ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
		             beanFactory.registerSingleton("springApplicationArguments", applicationArguments); // 将上下文中的内容变成一个singleton bean
                     listeners.contextLoaded(context); // 启动被监听的监视器
                )
        2.4.2.6 项目启动的过程中，诸多被加载的组件也需要同步开始运行，而这些组件大多需要进行一些额外的配置，例如数据库的连接信息，消息中间的服务端地址
                这些额外的配置通过spring-autoconfigure-metadata.properties文件中指定的组件代码入口上的@EnableConfigurationProperties(xxxProperties.class)
                xxxProperties.class来读取额外的配置信息


       

3、设计模式（一）：
    3.1 装饰器模式：结构型模式
        装饰器模式践行了设计模式大原则中的开闭原则（即：对扩展开发，对修改关闭），其作用在于在不改变原有功能的前提下，通过装饰器对功能提供扩展
        实现装饰器的条件：
        准备过程：
        1、baseClass = > method_1,method_2,...,method_n
        2、decorateClass =>protected arg baseClass , constructor(baseClass),@Override method_1( extendtion method)
        调用方式：
        DecorateClass decorateClass = new DecorateClass(baseClass); // 通过装饰器类对基类进行包装
        decorateClass.method_1() => 此时执行的是被扩展的method_1 的结果 
        装饰器本身最好是一个abstract类，方便被同类型但需要个性化扩展方法的类继承并重写装饰的方法
    3.2 策略模式：


第三周(2019/11/04 - 2019/11/08) 
已完成的任务：
1、学习spring-session组件，以及通过spring session 来实现分布式回话管理
    1.1 session是什么？
        在解释session是什么之前，先了解一下一个网络请求的执行过程。大部分的网络请求都使用http/https协议进行，这种通信协议的具有无状态的
        【无状态性】指：上一个请求和下一个请求之间是没有任何关联，上个请求中的结果不会影响下个请求。
        设想一个情景：即如果 url—1 是负责对请求者身份进行认证，url-2是向用户提供购物功能。基于http协议的无状态性，用户通过url-1完成了身份认证，
        跳转到url-2，但是url-2无法从url-1中获取用户的任何信息，必须要再次进行一次查询操作才能获得用户的相关信息。这样势必会十分影响系统性能。
        为了解决这个问题，首先诞生了【cookie技术】，这种在服务器相应了客户端请求后，将和客户端操作相关的一小部分信息存储与客户端（例如：浏览器中）
        这样一来，就可以将通过上个请求拿到的相关信息留存下来，供下一个请求使用。但是，cookie存在容量和安全问题，因为信息存放于客户端，用户便可以随意修改cookie中存放的信息。
        因此，更进一步【session技术】就应运而生了。session不仅保存请求过程产生的信息，还因其存放与服务端用户不能随意修改，保证了信息的安全性。
    1.2 session是一种控制管理前后台请求访问过程中产生的一些通用信息的技术。例如，a页面会产生用户信息，b页面需要获得用户名字，c页面需要获取用户年龄
        如果有session的介入，就可以将访问a页面时的用户信息存入【session指定的容器】中，b,c页面可以从session容器中获得需要的信息
    1.3 session容器：是指用来存储会话中产生的相关信息的地方。
        最初这些会话信息是存放在网络服务器中（例如：tomcat），会话信息只能在当前tomcat中流转。
        但是，随着互联网技术的发展和微服务架构被广泛使用后，每个微服务都独享资源，那么会话就需要在这个微服务集中共享。因此，可以将某些具有存储功能的中间当作session容器
        例如：redis，mongodb，sql数据库
    1.4 session是怎么生成的？
        session是有服务端控制的会话技术，因此session也是来自于后端
        session产生的流程：客户端发起请求 访问 httpServletReqeust接口并调用其get.session(ture)方法，
        如果是客户端的第一次请求,那么就会为本次会话创建一个session信息，可以用来存放客户端与服务端交互过程中需要用到的相关信息，并且生成一个sessionId返回给客户端，sessionid是客户端维护与服务端会话的重要唯一标示
        sessionId -> session
        如果客户端已经访问过服务端，那么就通过sessionId获取已存在的session信息
        session完全由服务端控制，一个session信息的创建，修改，删除都是在服务端进行。因此假定一个浏览器关闭了，是不会删除session信息。除非打开另一个浏览器时，这样就服务器就会将其认定为另一个客户端，sessionId将重新生成
    1.4 spring session:是一套有spring提供的实现session管理的接口
        使用 spring-session-redis来管理session
        1.4.1 引入依赖
        1.4.2 进行配置：redis的连接配置，springsession的属性配置
                     【未解决指定session的redis db】
        1.4.3 配置session的序列化策略：com.f.a.kobe.config.SessionConfig
2、关于redis的序列化策略的问题：
    redis序列化的规则，在数据存取过程中的数据格式的约定。
    在通过redistemplate向redis存取数据时，首先会经过一个raw(xxx)的办法，这个方法的作用就是将被操作的按照指定的方式进行序列化或反序列化
    指定序列化的方式是在redistemplate初始化的时候进行
    redistemplate的初始化有两种方式：1、使用模式的redisTemplate，(springboot自动化配置中提供的方案)
                                  2、使用自定义的redisTemplate，在此时指定key/value的序列化：
        【例如：】
        regionRedisTemplate.setKeySerializer(new StringRedisSerializer()); //key的序列化策略
		regionRedisTemplate.setValueSerializer(new FastJsonRedisSerializer<>(Object.class)); //value 的序列化策略
		
		// 设置hash key & value的序列化策略
		regionRedisTemplate.setHashKeySerializer(new StringRedisSerializer());
		regionRedisTemplate.setHashValueSerializer(new FastJsonRedisSerializer<>(Object.class));
		
		//regionRedisTemplate.setDefaultSerializer(new FastJsonRedisSerializer<>(Object.class));
		regionRedisTemplate.afterPropertiesSet(); // 这一步是让自定义的序列化策略生效

    【注意：】在redis-cli中对数据进行查询时，也是要遵循存入数据时的序列化策略的
            如果在存数据时，当前的key未使用new StringRedisSerializer()策略，那么直接使用get key 是会返回 nil，
            原因就是redis-cli get key的默认是string类型的，但是存入的数据又未被StringRedisSerializer，因此是找不到对应数据类型的key导致

第三周(2019/11/11 - 2019/11/15)
已完成的任务：
1、用户基本信息原子服务开发
2、用户地址原子服务开发
3、用户体征信息服务开发
4、向redis同步地址信息，从redis中获取地址信息功能开发
5、【关于通过向redis同步地理位置信息的总结】

第三周(2019/11/18 - 2019/11/22)
已完成的任务：
1、利用redis的atomicLong的自增特性来实现生成全局唯一有序id的功能
  1.1 生成全局有序id的原理是利用redis的incr命令，对指定的key进行自增。并拼接也是规则生成。
  1.2 使用spring-data-redis提供的 RedisAtomicLong.incrementAndGet() 进行
  1.3 这个api底层通过execute(connection -> connection.incrBy(rawKey, delta), true) 调用 redis的 incr 命令对当前key进行自增。
  1.4 如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCR 操作。 
  1.5 此层实现原理：
      127.0.0.1:6379> set num 10
      OK
      127.0.0.1:6379> incr num
      (integer) 11
      127.0.0.1:6379> get num    # 数字值在 Redis 中以字符串的形式保存
      "11"
  1.6 java实现过程：利用
      1.6.1 先声明一个基于RedisAtomicLong的计数器，通过RedisAtomicLong counter = new RedisAtomicLong(key, redisTemplate.getConnectionFactory());
            的构造方法配置需要自增的key，redisconnection，以及过期时间
      1.6.2 key是指计数器的名称(counter_name),如果不同的计数器需要不同的计数器来计算序列号，就各自声明即可。
      1.6.3 【注意】：在声明时不要指定初始值，因为如果一旦指定，每当项目重写启动时，就会将这个key重设为初始值
      1.6.4 key的过期时间的配置：通过counter.expireAt(todayEnd.getTime());配置这个计数器的归零的时刻
            例如 todayEnd.getTime() = 每日的23:59:59:999 就是表示在这个时刻，将计数器key清空重新开始计数。
      1.6.5 【此方法不适用于有[redis集群]的生成全局唯一有序id的场景】
2、通过 WebMvcConfigurationSupport 进行mvc的配置，并结合自定义参数解析器HandlerMethodArgumentResolver实现从session获取请求者信息并转换为当前的请求对象userAgent
   实现步骤如下：
   2.1 new class WeConfig extends WebMvcConfigurationSupport 【 WebMvcConfigurationSupport 新版本springboot推荐使用 】
   2.2 WebMvcConfigurationSupport 已经实现了springmvc功能的默认实现，WeConfig类继承并重写WebMvcConfigurationSupport中的部分方法，是为了配置适用与本项目的个性化功能
   2.3 HandlerMethodArgumentResolver 是一个参数解析器，这个参数解析器【必须】要配合拦截器共同使用，其作用是从拦截的请求中获取一些参数，
       并将这些参数进行包装并改写成为一个ctrl的入参，例如：@PathVariable 注解
       2.3.1 自定义的参数解析器，例： UserAgentResolver implements HandlerMethodArgumentResolver 接口
       2.3.2 重写 supportsParameter 方法，在其中【定义这个参数解析要匹配的参数类型】，例如 UserAgentResolver指定解析UserAgent.class 
             一旦在被拦截的请求路径中springmvc发现需要用到UserAgent类型的参数是，就会进入这个UserAgentResolver进行解析；
       2.3.3 重写 resolveArgument 方法，在这个方法中从被拦截的请求中获取需要的信息，然后经过处理，转换成supportsParameter 中定义的数据类型，
             NativeWebRequest(webRequest)类是获取请求信息的入口，webRequest.getAttribute(ATTR_NAME, RequestAttributes.SCOPE_SESSION);
             RequestAttributes.SCOPE_SESSION -> 从session中获取数据
             RequestAttributes.SCOPE_REQUEST -> 从request中获取数据
             ATTR_NAME -> 指定需要被获取的属性
   2.4 配置拦截器 UserSessionInterceptor implements HandlerInterceptor 
        preHandle ——> 请求已经拦截，但是在执行处理方法之前 -》 例如：拦截请求中是否具备用户的认证信息
        postHandle ——> 请求逻辑已经执行，但是在渲染页面之前 -》 例如：对响应数据进行格式化之后再渲染到页面上
        afterCompletion ——> 请求已经执行结束后 -》 例如：执行完成后记录日志
       自定义的拦击器可以根据需求选择性的重写这三个方法，也可以只是实现不重写，作为一项显式声明的拦截策略存在于WebMvcConfigurationSupport中，配合其他组件来使用
   2.5 开始配置WebMvcConfigurationSupport 
        重写 public void addInterceptors(InterceptorRegistry registry)  方法： 针对某个拦截器指定需要执行的匹配路径。
            使用registry.addInterceptor(自定义拦截器类).addPathPatterns(拦截路径[支持通配符])
                                                    .excludePathPatterns(需要排除的拦截路径[支持通配符])
        重写 public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) 配置请求数据解析器
            使用 argumentResolvers.add(new UserAgentResolver()); 将自定义的数据解析器加入到springmvc配置中
        重写 public void configureMessageConverters(List<HttpMessageConverter<?>> converters) 配置消息的转换器，一般是为了解决中文乱码或者请求内容支持的相关问题
            converters.add(new StringHttpMessageConverter(Charset.forName("UTF-8"))); // 解决中文乱码问题
		    converters.add(new MappingJackson2HttpMessageConverter()); // 解决 application/json；charset=utf-8 unsupported mediaType 的问题

    【重点总结：HttpMessageConverter】
     springmvc框架是一套mvc框架，其作用是将请求、响应和页面渲染解耦。其最核心的组件是 DispatcherServlet类，有这个类提供请求拦截和跳转控制以及页面渲染的工作。
     不过DispatcherServlet的执行也是需要加载一些相关资源的，这个资源的配置在WebMvcConfigurationSupport中进行。
     WebMvcConfigurationSupport中的getMessageConverters()方法是用来配置本项目中需要的消息解析器，其中有个重要的判断逻辑：
        如果没有自定义的HttpMessageConverters就进行默认加载，其中加载的new StringHttpMessageConverter()的默认字符集是ISO-8859-1
       【反之则只加载用户自定义的HttpMessageConverters】：因此就出现了如果在拦截器中重写StringHttpMessageConverter的charset = utf-8 后，就没办法拦截@Requestbody注解的请求（content-type:application/json）
        此时使用重写extendMessageConverters方法，用来对在默认加载的HttpMessageConverters进行扩展，而不是清空默认列表
     WebMvcConfigurationSupport 是在项目启动是就会根据默认/自定义配置加载到springIOC中，提供了解析各种content-type的支持，等到DispatcherServlet开始执行请求响应流程时提供支持；
     
     请求和响应在被DispathcheServlet处理
        执行doDispath方法
            调用 -> HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler()); // 获得处理器
            当前处理器 执行 mv = ha.handle(processedRequest, response, mappedHandler.getHandler());  //正式处理请求和响应的结果
            /*
             *在正式过程中会将请求包装成 HttpInputMessage 传入AbstractMessageConverterMethodArgumentResolver.readWithMessageConverters()方法中
             *判断当前的请求类型是否能被来自于WebMvcConfigurationSupport中的List<HttpMessageConverter<?>>列表中的解析器某一个read 
             */
             /*
             *在系统处理完成后返回数据会被包装成 HttpOutputMessage 传入 AbstractMessageConverterMethodProcessor.writeWithMessageConverters()方法中
             *判断当前的请求类型是否能被来自于WebMvcConfigurationSupport中的List<HttpMessageConverter<?>>列表中的解析器某一个write
             */
             最后调用invokeHandlerMethod方法，完成请求的受理
3、 梳理并完成用户登陆，注册，手机号绑定的功能

第四周(2019/11/15 - 2019/11/29)
已完成的任务：
1、完成用户地址信息维护功能
2、完成用户体征信息结构化数据，构建业务视图并同步到mongodb中
3、使用CountDownLatch类，在单元测试中使用多线程来方式来测试，通过CountDownLatch也是一种让主线程等待子线程完成后结束的方法，Thread.join() 方式类似
   有点在于，使用CountDownLatch是异步进行的，子线程不需要排队，非常适用于模拟高并发请求。
   用法 ：主线程 声明 CountDownLatch countDownLatch = new CountDownLatch(count); // count 是线程计数器，一般与需要开启的线程数量一致
               子线程： forkThread(CountDownLatch countDownLatch)
                            --> run(){
                                // do xxxx
                                countDownLatch.countDown();  // 子线程run方法中业务执行完成后 调用 countDownLatch.countDown(); 扣减计数器
                            }
        主线程： countDownLatch.await();   //主线程等待子线程进行完毕
4、关于mysql-connector-java 8.0X 版本的jdbc连接配置的正确写法
    driverClassName: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://118.190.53.214:3386/fa_kobe?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=GMT%2B8

5、开发chart数据视图功能

第四周(2019/12/01 - 2019/12/06)
1、SpringSession实现会话信息共享的机制的分析
  1.1 SpringSession 是一个用于分布式系统共享会话信息的一种技术方案，可以解决微服务系统架构中用户请求会话共享的难题
  1.2 SpringSession 对系统而言，是一个代替传统由网络服务器存放和维护会话管理的机制，SpringSession中提供了一个用来存储和维护会话信息的接口，SessionRepository
      这个接口提供了不同的数据存放方案，例如：RedisSessionRepository,MongoSessionRepository 等
  1.3 加载过程：
    web项目启动时的web组件加载过程：context-param -> listener -> filter -> servlet
    会话管理器是在一个项目中只需要被配置一次，然后全局使用，所以这是一个过滤器filter的配置
    >>>>>> filter注册流程
    由class SessionRepositoryFilter 选中需要加载的SessionRepository
    由class s SessionRepositoryFilterConfiguration.FilterRegistrationBean 将被选中的SessionRepository的实现注册到filter中
    那么SessionRepositoryFilter 又是如何选中 SessionRepository的具体实现方案的呢？
    >>>>>> sessionRepository选中流程
    【重点：@EnableRedisHttpSession】这个注解是使用redis作为sessionRepository的开关
    @EnableRedisHttpSession -> @Import(RedisHttpSessionConfiguration.class) 
    - > RedisHttpSessionConfiguration implements SpringHttpSessionConfiguration,BeanClassLoaderAware
                |—— @Override BeanClassLoaderAware.setBeanClassLoader () // 在项目启动时将当前类初始化成一个bean
                |—— @Bean public RedisIndexedSessionRepository sessionRepository() 将RedisIndexedSessionRepository初始化为sessionRepository
    这样以来，就会在启动的时候，将RedisIndexedSessionRepository作为选中的sessionRepository方案了
    【注意：**sessionRepository只是作为session的存储和维护的方案，也就是说，这只是springsession中的一个部分】
    >>>>>>> 获取session的过程
    所有的请求请求进入系统的过程中，需要先通过filter，通过过滤器链filterChain.doFilter(request, response); 执行dofilter方法，将请求交给系统中已经配置了过滤器
    如果配置SessionRepositoryFilter 那么，将请求交给 SessionRepositoryFilter.doFilterInternal()方法
    在这个方法中会通过 new SessionRepositoryRequestWrapper(request, response)，对当前的请求进行一次在此包装
    这个包装中最重要的步骤
        >>> 解析sessionId : httpSessionIdResolver.resolveSessionIds(this);   //this 是当前请求
        >>> 查询sessionId : sessionRepository.findById(sessionId)
        >>> 设置session : setCurrentSession(currentSession); 将SessionRepository存放的session信息，设置到服务端session中
        setCurrentSession方法 返回 HttpSessionWrapper 对象，这个对象继承HttpSessionAdapter，HttpSessionAdapter又实现了HttpSession的方法
        因此，如果需要获得session信息时，直接使用HttpServletRequest.getSession().getAttribute(“attr_name”);就可以获得到了
    【****这样做的好处是：无论session采用什么方案进行存储，但是对于获取session的方法与普通做法都没有任何区别****】

2、使用header来代替cookie 实现session信息的共享，使用如下方案，替换默认配置即可
    @Bean
	public HttpSessionIdResolver httpSessionIdResolver() {
		return HeaderHttpSessionIdResolver.xAuthToken(); 
	}
    HttpSessionIdResolver：是一个session解析器接口
        ｜—— CookieHttpSessionIdResolver // 默认实现，从cookie中获取session信息
        ｜—— HeaderHttpSessionIdResolver // 从header中获取session信息 

3、搭建kidd项目作为网关，实现在微服务架构中session的共享
4、改造kobe项目，将其他项目中可能会用到组件进行抽离
    >>>> 踏坑：
        在进行公用组件抽离之时，希望将用于将userAgent的转换器配置独立成一个 UserAgentConfig.class extends WebMvcConfigurationSupport  并加上注解@Configure。
        预期是：UserAgentConfig 仅作为配置请求参数中userAgent的转换器配置，可与其他的WebMvcConfigurationSupport共同使用。
        实际上：一个项目中只能存在一个WebMvcConfigurationSupport
        最后方案：只是将userAgentResolver抽离出来，并将其声明为一个bean，在各自项目中的WebMvcConfigurationSupport中加入到参数解析器列表
        详情见：/kobe/src/main/java/com/f/a/kobe/config/webconfig/WebConfig.java









        
